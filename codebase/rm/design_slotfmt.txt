A data page needs to organize records by altering, moving, and relocating records.
This must be done without modifying the Record IDs (page_num, slot_num).

The Slotted Page Format will help deal with these issues.

Note the following distinction between free vs. unused space:
- free space refers to the amount of contiguous free space, after the records.
- unused space refers to the amount of unused space regardless of fragmentation.

Slotted Page Format:
- The slotted page format has three classes of data that require management:
  * records
  * slot directory
  * unused space

- The slot directory has the following information:
  * 2 bytes: offset to start of free space (2 bytes)
  * 2 bytes: number of slots (2 bytes)

  * For each slot:
      2 bytes: offset to start of record

- The slot directory grows from the end of the page towards the start of the page.

- Initially the free space begins at the top of the page, at offset 0.

- When a record is inserted, the following may occur:
  1. There is enough free space for a new slot and the record.
     Steps:
       * Update slot count
       * Insert slot
       * Insert new record
         - append to free space
         - update free space offset
       * Update unused space in control page.

  2. There is not enough free space, but enough unused space for a new slot and record.
     Steps:
       * Compact page
       * Update slot count
       * Insert slot
       * Insert new record
       * Update unused space in control page.

  3. There is not enough free or unused space:
     This case shouldn't occur if inserts find the first page with available unused space in the control page.


- When a record is altered, the following may occur:
  1. Record size shrinks.
     Steps:
       * Update unused space in control page.

  2. Record size grows. Enough free space available:
     Steps:
       * Move record to free space.
       * Update slot offset.
       * Update unused space in control page.

  3. Record size grows. Enough unused space:
     Steps:
       * Compact page
       * Move record to free space.
       * Update slot offset.
       * Update unused space in control page.

  4. Record size grows. Not enough free/unused space:
     Steps:
       * Find first page with free space.
       * Insert record.
       * Write RID for tuple redirection.
       * Update unused spacein control page.

- When a record is deleted:
  - if slot is the last slot, delete the slot.
  - if slot is not the last slot, set offset to 0x8000 (most significant bit is 1).
  - update unused space in control page.

Compaction Algorithm:

Compacting is difficult and expensive computationally.

1. Construct a list of (slot_id, offset) tuples.
2. Sort on the offset field.
3. The list will now be a sorted arrangement of the original list.
4. Adjacent (slot_id, offset) tuple, correspond to the right-adjacency.
5. Compact all adjacent records, tuple redirects, etc.
6. Rewrite all the offsets.

Alternative 1:
  * Requires each unused fragment to have at least 2 bytes.
    - Tricky case for altered records of -1 bytes.
    - Use linear search or hash table (key=offset) on the slot directory.
      
  * Stores the amount of free space in the fragment.

  * To indicate the free space, mask the first 4 bits.

  * e.g. If there's 512 bytes space in the fragment:
         int16_t *fragment = (int16_t *) fragment_ptr; // cast as 16-bit int
         *fragment = 0xF0 | 512

         Check if it's a fragment:
         int16_t *check = record + record_length;
         if((*check & 0xF0) == 0xF0) // then it's an unused fragment

  * By masking the first 4 bits, it's easy to tell if there's an adjacent
    record, tuple redirection, or unused space fragment.

  * Problem: We cannot determine the adjacent record in the slot.
             - See Alternative 2 for solution.

Alternative 2:
  * Same premise as alternative 1, but instead store the slot number
    of the adjacent record (in the direction of end of page).

  * Solves problem of identifying the adjacent record and slot.

  * Problem: Cannot identify the adjacent slot number if the packing is
             already contiguous?

  * Solution: A partial solution is to skip contiguous records. The fragments
              are only a concern for records adjacent to the end of a fragment.

              However altering a record might require compaction of adjacent
              records, and in such case, it might be easy to pay the cost of
              a linear scan to identify the slot.

Free Slot Management;
  * When inserting a record a slot needs to be acquired.
    - We can either append a new slot or reuse a slot that was previous deallocated.
    - In this case, we can represent an implicit linked list, where deleted slots will have the most significant bit set to 1.
      A 2 byte field will represent the next unused slot. In each unused slot, the next unused slot will be embedded.
      When inserting, the unused slot number will be used if there's unused slots (again check most significant bit). 
