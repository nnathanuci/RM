
@nnathan Page File Format-------------------------------------------------------

Table data is stored stored in heap files.

- Each page in the heap is 4096 bytes (4KB) in size.

- A page is either:
  * a control page
  * a data page

- The space needed to address a page is 12 bits. When convenient we use
  2 bytes instead.

Control Pages:

- A control page tells us the amount of unused space in a data page.

- The format for a control page is as follows:
  (unused_0, unused_1, unused_2, ..., unused_k, ..., next_control_pid)

  * next_control_pid is an unsigned 32-bit int, stored at offset 4092
    in the page. It indicates the next control page, page id.

- For example, to find the amount of unused space for page 20.
  Calculate the bit offset:            20*12 = 240.
  Find the byte offset:                240 / 8 = 30
  Find the remaining bit offset:       240 % 8 = 0
  Find the amount of unused space:     unsigned short x = (page[30] << 4) | (page[31] >> 4)

--------------------------------------------------------------------------------
@nnathan Slot Format------------------------------------------------------------
A data page needs to organize records by altering, moving, and relocating records.
This must be done without modifying the Record IDs (page_num, slot_num).

The Slotted Page Format will help deal with these issues.

Note the following distinction between free vs. unused space:
- free space refers to the amount of contiguous free space, after the records.
- unused space refers to the amount of unused space regardless of fragmentation.


Slotted Page Format:
- The slotted page format has three classes of data that require management:
  * records
  * slot directory
  * unused space

- The slot directory has the following information:
  * 2 bytes: offset to start of free space (2 bytes)
  * 2 bytes: number of slots (2 bytes) 

  * For each slot:
      2 bytes: offset to start of record

- The slot directory grows from the end of the page towards the start of the page.

- Initially the free space begins at the top of the page, at offset 0.

- When a record is inserted, the following may occur:
  1. There is enough free space for a new slot and the record.
     Steps:
       * Update slot count
       * Insert slot
       * Insert new record
       * Update unused space in control page.

  2. There is not enough free space, but enough unused space for a new slot and record.
     Steps:
       * Compact page
       * Update slot count
       * Insert slot
       * Insert new record
       * Update unused space in control page.

  3. There is not enough free or unused space:
     This case shouldn't occur if inserts find the first page with available unused space in the control page.

- When a record is altered, the following may occur:
  1. Record size shrinks.
     Steps:
       * Update unused space in control page.

  2. Record size grows. Enough free space available:
     Steps:
       * Move record to free space.
       * Update slot offset.
       * Update unused space in control page.

  3. Record size grows. Enough unused space:
     Steps:
       * Compact page
       * Move record to free space.
       * Update slot offset.
       * Update unused space in control page.

  4. Record size grows. Not enough free/unused space:
     Steps:
       * Find first page with free space.
       * Insert record.
       * Write RID for tuple redirection.
       * Update unused spacein control page.

- When a record is deleted, update offset to 4096 (or some other way to say its deleted), and updateunused space in control page.
--------------------------------------------------------------------------------
@darkhipo questions:
  
 Steps For Insert data_tuple into table "table":
  
 Lookup catalog table info for "table", this gets you the attributes vector.
 
 Produce a record of size r_b bytes using the attributes, and the data given.
 
 Test whether r_b <= PAGE_SIZE if so error out otherwise continue. 
 
 Identify page with sufficient space to accomodate all r_b bytes of the record.
 *Do this by reading in the control page, and sequentially reading the vector
 (free_0, free_1, free_2, ..., free_k, ..., next_control_pid) until a space 
 large enough is found. (say it is found at free_i)*
 
 Identify the starting offset within data page i of a memory slot large enough 
 to accomodate r_b bytes call it i_fo. (How are we doing this ?) 
 
 Read slot table at page i, add a new record id (rid) for the record into 
 the slot table. call it rid_r (How are we doing this ?)
 
 Modify the slot table so that SLOT_TABLE[rid_r] = i_fo (or = i_fo + r_b ?)
 
 Write the record on page i, on bytes [i_fo, i_fo + r_b].
 

 ^^Question: Can you look through that and change what you think is wrong or 
 imprecise ?
